import type {
  APIActionRowComponent,
  APIAttachment,
  APIButtonComponentWithCustomId,
  APIButtonComponentWithURL,
  APIChannel,
  APIEmbed,
  APIMessage,
  APIMessageActionRowComponent,
  APIRole,
  Snowflake,
} from "../deps.ts";
import { ButtonStyle, logger, MessageType } from "../deps.ts";
import Midjourney from "./Midjourney.ts";
import type { ResponseType, UserReference } from "./models.ts";
import { REROLL } from "./utils.ts";

export interface ComponentsSummary {
  parentId: Snowflake;
  processed: boolean;
  label: string;
  custom_id: string;
}

export interface SplitedPrompt {
  source: string;
  prompt: string;
  id?: string;
  mode?: "fast" | "relaxed";
  type?: ResponseType;
  name: string;
  completion?: number; // 0..1
}

export class componentData {
  public processed: boolean;
  public label: string;
  public custom_id: string;
  public url: string;

  constructor(
    public readonly parentId: Snowflake,
    src: APIButtonComponentWithCustomId | APIButtonComponentWithURL,
  ) {
    this.processed = src.style === ButtonStyle.Primary; // 1 is primary button means that it had already been click
    this.label = src.label || src.emoji?.name || "N/A";
    if ("custom_id" in src) {
      this.custom_id = src.custom_id || "";
      this.url = "";
    } else {
      this.custom_id = "";
      this.url = src.url || "";
      if (this.url) {
        this.processed = true;
      }
    }
  }
}

export function extractPrompt(content: string): SplitedPrompt | undefined {
  let m = content.match(/^\*\*(.+)\*\* - (.+)$/); // (.+) <@(\d+)>
  if (!m) {
    return undefined;
  }

  const prompt: SplitedPrompt = {
    prompt: m[1],
    source: content,
    name: "",
  };
  let extra = m[2];
  if (extra.endsWith(" (fast)")) {
    prompt.mode = "fast";
    extra = extra.substring(0, extra.length - 7);
  } else if (extra.endsWith(" (relaxed)")) {
    prompt.mode = "relaxed";
    extra = extra.substring(0, extra.length - 10);
  }
  m = extra.match(/^<@(\d+)> \(Open on website for full quality\)$/);
  if (m) {
    prompt.id = m[1];
    prompt.completion = 1;
    prompt.type = "grid";
    return prompt;
  }

  m = extra.match(/^Variations by <@(\d+)>$/);
  if (m) {
    prompt.id = m[1];
    prompt.completion = 1;
    prompt.type = "variations";
    return prompt;
  }

  m = extra.match(/^Upscaled by <@(\d+)>$/);
  if (m) {
    prompt.id = m[1];
    prompt.completion = 1;
    prompt.type = "upscale";
    return prompt;
  }

  m = extra.match(
    /^Variations by <@(\d+)> \(Open on website for full quality\)$/,
  );
  if (m) {
    prompt.id = m[1];
    prompt.completion = 1;
    prompt.type = "variations";
    return prompt;
  }

  m = extra.match(/^Image #(\d) <@(\d+)>$/);
  if (m) {
    prompt.id = m[2];
    prompt.completion = 1;
    prompt.type = "upscale"; // or variations
    prompt.name = `Image #${m[1]}`;
    return prompt;
  }

  m = extra.match(/^<@(\d+)> \((\d+)%\)$/);
  if (m) {
    prompt.id = m[1];
    prompt.completion = parseInt(m[2]) / 100;
    prompt.type = "grid";
    return prompt;
  }

  m = extra.match(/^<@(\d+)> \(Waiting to start\)$/);
  if (m) {
    prompt.id = m[1];
    prompt.completion = -1;
    prompt.type = "grid";
    return prompt;
  }
  m = extra.match(/^<@(\d+)>$/);
  if (m) {
    prompt.id = m[1];
    prompt.completion = 1;
    prompt.type = "grid";
    return prompt;
  }

  if (!extra.length) {
    return prompt;
  }
  logger.warn("Failedto extract prompt data from:", content);

  // // dual () is note, mode
  // m = content.match(/^\*\*(.+)\*\* - <@(\d+)> \(([^)])\) \(([^)])\)$/);
  // if (m)
  //     return { prompt: m[1], name: "", id: m[2], note: m[3], mode: m[4] };
  // // single () is mode
  // m = content.match(/^\*\*(.+)\*\* - <@(\d+)> \(([^)]+)\)$/);
  // if (m)
  //     return { prompt: m[1], name: "", id: m[2], note: "", mode: m[3] };
  // return prompt;
}

export class DiscordMessage implements APIMessage {
  /**
   * ID of the message
   */
  id!: Snowflake;
  /**
   * ID of the channel the message was sent in
   */
  channel_id!: Snowflake;
  /**
   * The author of this message (only a valid user in the case where the message is generated by a user or bot user)
   *
   * If the message is generated by a webhook, the author object corresponds to the webhook's id,
   * username, and avatar. You can tell if a message is generated by a webhook by checking for the `webhook_id` property
   *
   * See https://discord.com/developers/docs/resources/user#user-object
   */
  author!: UserReference;
  /**
   * Contents of the message
   *
   * The `MESSAGE_CONTENT` privileged gateway intent will become required after **August 31, 2022** for verified applications to receive a non-empty value from this field
   *
   * In the Discord Developers Portal, you need to enable the toggle of this intent of your application in **Bot > Privileged Gateway Intents**
   *
   * See https://support-dev.discord.com/hc/articles/4404772028055
   */
  content: string;
  /**
   * When this message was sent
   */
  timestamp!: string;
  /**
   * When this message was edited (or null if never)
   */
  edited_timestamp!: string | null;
  /**
   * Whether this was a TTS message
   */
  tts!: boolean;
  /**
   * Whether this message mentions everyone
   */
  mention_everyone!: boolean;
  /**
   * Users specifically mentioned in the message
   *
   * The `member` field is only present in `MESSAGE_CREATE` and `MESSAGE_UPDATE` events
   * from text-based guild channels
   *
   * See https://discord.com/developers/docs/resources/user#user-object
   * See https://discord.com/developers/docs/resources/guild#guild-member-object
   */
  mentions!: UserReference[]; // extention from APIUser
  /**
   * Roles specifically mentioned in this message
   *
   * See https://discord.com/developers/docs/topics/permissions#role-object
   */
  mention_roles!: APIRole["id"][];

  /**
   * Any attached files
   *
   * See https://discord.com/developers/docs/resources/channel#attachment-object
   *
   * The `MESSAGE_CONTENT` privileged gateway intent will become required after **August 31, 2022** for verified applications to receive a non-empty value from this field
   *
   * In the Discord Developers Portal, you need to enable the toggle of this intent of your application in **Bot > Privileged Gateway Intents**
   *
   * See https://support-dev.discord.com/hc/articles/4404772028055
   */
  attachments!: APIAttachment[];

  /**
   * Any embedded content
   *
   * See https://discord.com/developers/docs/resources/channel#embed-object
   *
   * The `MESSAGE_CONTENT` privileged gateway intent will become required after **August 31, 2022** for verified applications to receive a non-empty value from this field
   *
   * In the Discord Developers Portal, you need to enable the toggle of this intent of your application in **Bot > Privileged Gateway Intents**
   *
   * See https://support-dev.discord.com/hc/articles/4404772028055
   */
  embeds!: APIEmbed[];
  /**
   * Whether this message is pinned
   */
  pinned!: boolean;
  /**
   * Type of message
   *
   * See https://discord.com/developers/docs/resources/channel#message-object-message-types
   */
  type!: MessageType;
  /**
   * Message flags combined as a bitfield
   *
   * See https://discord.com/developers/docs/resources/channel#message-object-message-flags
   *
   * See https://en.wikipedia.org/wiki/Bit_field
   */
  flags?: number; //MessageFlags;

  /**
   * Sent if a thread was started from this message
   */
  thread?: APIChannel;

  /**
   * Sent if the message contains components like buttons, action rows, or other interactive components
   *
   * The `MESSAGE_CONTENT` privileged gateway intent will become required after **August 31, 2022** for verified applications to receive a non-empty value from this field
   *
   * In the Discord Developers Portal, you need to enable the toggle of this intent of your application in **Bot > Privileged Gateway Intents**
   *
   * See https://support-dev.discord.com/hc/articles/4404772028055
   */
  components?: APIActionRowComponent<APIMessageActionRowComponent>[];

  /**
   * The message associated with the `message_reference`
   *
   * This field is only returned for messages with a `type` of `19` (REPLY).
   *
   * If the message is a reply but the `referenced_message` field is not present,
   * the backend did not attempt to fetch the message that was being replied to,
   * so its state is unknown.
   *
   * If the field exists but is `null`, the referenced message was deleted
   *
   * See https://discord.com/developers/docs/resources/channel#message-object
   */
  public referenced_message?: DiscordMessage | null;

  public prompt?: SplitedPrompt;

  public componentsSummery: ComponentsSummary[];

  /**
   * parent client
   */
  #client: Midjourney;

  constructor(client: Midjourney, public source: APIMessage) {
    Object.assign(this, source);
    this.#client = client;
    // this.id = source.id;
    this.prompt = extractPrompt(source.content);
    this.content = source.content;
    this.componentsSummery = getDataFromComponents(
      source.id,
      source.components || [],
    );
    if (source.referenced_message) {
      this.referenced_message = new DiscordMessage(
        client,
        source.referenced_message,
      );
    }
    // labels: '1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£4ï¸âƒ£ðŸ”„'
    // const labels = this.components.map(a => a.label).join('');
    // const custom_ids = this.components.map((a) => a.custom_id).join("");
    if (source.interaction) {
      const name = source.interaction.name;
      if (name === "describe") {
        if (source.embeds && source.embeds[0]) {
          const embeds: APIEmbed = source.embeds[0];
          if (embeds.image) {
            const description: string = embeds.description || "";
            this.prompt = {
              source: description,
              type: "describe",
              name: embeds.image.url.replace(/.+\//, ""),
              prompt: description,
              completion: 1,
            };
          }
        } else {
          // embeds not available yet.
          this.prompt = {
            source: "",
            type: "describe",
            name: "",
            prompt: "",
            completion: -1,
          };
        }
      } else {
        logger.info("interaction Name: ", name, this.prompt);
        // console.log("interaction source.embeds: ", source.embeds);
      }
    }
    //if (custom_ids.includes("MJ::Job::PicReader::")) {
  }

  private getComponentsByLabel(label: string): APIButtonComponentWithCustomId {
    if (!this.components) {
      throw Error("no components In this message.");
    }
    const availableLabels: string[] = [];
    for (const src of this.components) {
      for (const c of src.components) {
        if (!("custom_id" in c)) continue;
        if ("label" in c && c.label && c.label) {
          if (c.label === label) return c as APIButtonComponentWithCustomId;
          availableLabels.push(c.label);
        } else if ("emoji" in c && c.emoji && c.emoji.name) {
          if (c.emoji.name === label) {
            return c as APIButtonComponentWithCustomId;
          }
          availableLabels.push(`${c.emoji.name}`);
        }
      }
    }
    throw Error(
      `Failed to find componant named "${label}" within ${
        availableLabels.map((a) => `"${a}"`).join(", ")
      }`,
    );
  }

  /**
   * return if the the Message is upscalable, if an id is provide, will return true only if the requested action had not already been started.
   */
  canReroll(): boolean {
    try {
      this.getComponentsByLabel(REROLL);
      return true;
    } catch (_) {
      return false;
    }
  }

  /**
   * return if the the Message is upscalable, if an id is provide, will return true only if the requested action had not already been started.
   */
  canUpscale(id?: 1 | 2 | 3 | 4): boolean {
    const selector = id ? `U${id}` : "U1";
    try {
      const c = this.getComponentsByLabel(selector);
      if (id) {
        return !c.disabled && c.style !== ButtonStyle.Primary; // 1 is primary button means that it had already been click
      }
      return true;
    } catch (_) {
      return false;
    }
  }

  /**
   * return if the the Message can be varaint, if an id is provide, will return true only if the requested action had not already been started.
   */
  canVariant(id?: 1 | 2 | 3 | 4): boolean {
    const selector = id ? `V${id}` : "V1";
    try {
      const c = this.getComponentsByLabel(selector);
      if (id) {
        return !c.disabled && c.style !== ButtonStyle.Primary; // 1 is primary button means that it had already been click
      }
      return true;
    } catch (_) {
      return false;
    }
  }

  reroll(): Promise<DiscordMessage> {
    const comp = this.getComponentsByLabel(REROLL);
    const compData = new componentData(this.id, comp);
    logger.info(`${compData.custom_id} Reroll will be generated`);
    return this.#client.callCustomComponents(compData);
  }

  upscale(id: 1 | 2 | 3 | 4): Promise<DiscordMessage> {
    const label = `U${id}`;
    const comp = this.getComponentsByLabel(label);
    const compData = new componentData(this.id, comp);
    logger.info(`${compData.custom_id} Upscale will be generated`);
    return this.#client.callCustomComponents(compData);
  }

  variant(id: 1 | 2 | 3 | 4): Promise<DiscordMessage> {
    const label = `V${id}`;
    const comp = this.getComponentsByLabel(label);
    const compData = new componentData(this.id, comp);
    logger.info(`${compData.custom_id} Variant will be generated`);
    return this.#client.callCustomComponents(compData);
  }

  getComponents(processed: boolean, name?: string): ComponentsSummary[] {
    let list = this.componentsSummery.filter((a) => a.processed === processed);
    if (name) {
      list = list.filter((a) => a.label.startsWith(name));
    }
    return list;
  }
}

function getDataFromComponents(
  parentId: Snowflake,
  srcs: APIActionRowComponent<APIMessageActionRowComponent>[],
): componentData[] {
  const out: componentData[] = [];
  for (const src of srcs) {
    for (const c of src.components) {
      if ("custom_id" in c && ("label" in c || "emoji" in c)) {
        out.push(new componentData(parentId, c)); //  as APIButtonComponentWithCustomId
      } else if ("label" in c && "url" in c) {
        out.push(new componentData(parentId, c)); //  as APIButtonComponentWithURL
      } else {
        logger.warn("getDataFromComponents meat non supported component", c);
      }
    }
  }
  return out;
}
